%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lachaise Assignment
% LaTeX Template
% Version 1.0 (26/6/2018)
%
% This template originates from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Marion Lachaise & François Févotte
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{ITC-ADA-C1-2023: Assignment \#5} % Title of the assignment

\author{Luis Ballado\\ \texttt{luis.ballado@cinvestav.mx}} % Author name and email address

\date{CINVESTAV UNIDAD TAMAULIPAS --- \today} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

%--- cambiar estilo de secciones
\titleformat{\section}  % which section command to format
  {\fontsize{12}{12}\bfseries} % format for whole line
  {\thesection} % how to show number
  {1em} % space between number and text
  {} % formatting for just the text
  [] % formatting for after the text

\section{Diseñe e implemente los algoritmos necesarios para resolver eficientemente los dos incisos del problema 4.13 de la página 127 del libro de Dasgupta, Papadimitriou y Vazirani. Analice matemáticamente la complejidad temporal de sus algoritmos.}

\begin{question}
  \textbf{Dado un conjunto de ciudades, junto con el patrón de carreteras entre ellas, en forma de un gráfico no dirigido G=(V,E). Cada tramo de la carretera $e \in E$ conecta dos de las ciudades, y usted conoce su longitud en millas. Suponga que quiere ir de la ciudad $s$ a la ciudad $t$ . Pero hay un problema, su coche solo puede contener suficiente gasolina para cubrir L millas. Hay gasolineras en cada ciudad, pero no entre ciudades. Por lo tanto, solo se puede tomar una ruta si cada una de sus aristas tiene una longitud de $l_{e} \neq L$}

  a) Dada la limitación en la capacidad del tanque de combustible de su coche, muestre cómo determinar en tiempo lineal si existe una ruta factible de $s$ a $t$\\
  b) Ahora planea comprar un coche nuevo y desea saber cuál es el tanque mínimo de combustible que se necesita para viajar de $s$ a $t$. Proponga un algoritmo O(($|$V$|$ + $|$E$|$) log$|$V$|$) para determinar esto.
\end{question}
  
%se responde aquí
\textit{a) Para determinar si existe un camino de s $\implies$ t con las limitantes del tanque de gasolina del carro, podemos hacer uso del algoritmo de BFS; manteniendo un rastro de las ciudades visitadas y revisando cuando el costo de cada arista es menor o igual que la capacidad del tanque.\\\\ Si la corrida del algoritmo BFS logra alcanzar la ciudad destino, podemos decir que existe una ruta con la capacidad del tanque.\\\\ Comenzamos en la ciudad s y visitamos todas las ciudades adjacentes a ella que se puedan llegar con L millas, marcamos la ciudad como visitada y la agregamos a la cola, continuaremos este proceso hasta llegar a la ciudad destino o hasta que se acabe la gasolina. \\\\ La complejidad del algoritmo es \textbf{O($|$V$|$+$|$E$|$)} ya que visitamos todos los vertices y aristas una vez}\\\\

\textit{b) Para determinar la capacidad mínima, que necesitamos para viajar entre las ciudades de interés, podemos hacer uso de una búsqueda binaria comenzando con una mínimo de cero y una máxima distancia entre las dos ciudades en el grafo. Para así, haciendo uso de la búsqueda con las capacidades del tanque, se busca una ruta entre ciudades.\\\\ Para conocer si existe una ruta dada la capacidad del tanque, se hace uso nuevamente del algoritmo BFS, para buscar el camino más corto. \\Si existe, repetiremos la búsqueda binaria hasta encontrar la capacidad mínima que nos permita llegar de la ciudad s $implies$ t. \\\\ Dado que la búsqueda binaria corre en \textbf{O(log(v))} para cada iteración y cada iteración necesita correr el algoritmo BFS en el grafo cuyo costo es \textbf{O($|$V$|$+$|$E$|$)}, teniendo una complejidad total de \textbf{O($|$V$|$+$|$E$|$)log$|$V$|$)} }


\subsection{Implementación y corridas}

\href{https://github.com/luisballado/ADA/tree/main/practice_code/tarea5/car_highways}{ver código en github}\\

Ejecutar desde una terminal\\\\

El archivo data.txt contiene los datos de
\begin{itemize}
\item \textbf{número de ciudades, número de caminos}
\item \textbf{Seguido de las aristas (ciudad origen-ciudad destino) y sus respectivos pesos}
\item \textbf{ciudad origen, ciudad destino}
\end{itemize}

% Command-line "screenshot"
\begin{commandline}
\begin{verbatim}
  $ g++ -std=c++11 cars_highways.cpp -o cars_highways
  $ ./cars_highways < data.txt
  Existe una ruta de la ciudad 0 a la ciudad 4
  La capacidad minima del tanque para viajar de la ciudad 0 a la ciudad 4 es 8
\end{verbatim}
\end{commandline}

\newpage
\section{Diseñe e implemente un algoritmo que permita resolver eficientemente el inciso (a) del problema 4.21 de la página 130 del libro de Dasgupta, Papadimitriou y Vazirani. Analice matemáticamente la complejidad temporal de su algoritmo.}

\begin{question}
  \textbf{Los algoritmos de ruta más corta se pueden aplicar en el comercio de divisas. Sea $c_{1}$ , $c_{2}$ , ... , $c_{n}$ ser varias monedas; por ejemplo, $c_{1}$ podría ser dólares, $c_{2}$ libras y $c_{3}$ liras. Para dos monedas cualesquiera $c_{i}$ y $c_{j}$ , hay un tipo de cambio $r_{i,j}$ ; esto significa que puede comprar $r_{i,j}$ unidades de moneda $c_{j}$ en cambiar por una unidad de $c_{i}$. Estos tipos de cambio satisfacen la condición de que $r_{i,j} * r_{j,i} < 1$, de modo que si comienza con una unidad de moneda $c_{i}$ , la cambia a moneda $c_{j}$ y luego vuelve a convertirla a moneda $c_{i}$ , terminas con menos de una unidad de moneda $c_{i}$ (la diferencia es el costo de la transacción).}

  a) Realice un algoritmo eficiente: dado un conjunto de tipos de cambio $r_{i,j}$, y dos monedas s y t, encuentre la secuencia más ventajosa de cambios de moneda para convertir la moneda s en la moneda t. Represente las monedas y tasas en un grafo cuyas longitudes son números reales.
  
\end{question}

\textit{Podemos resolver el problema haciendo uso del algoritmo de Dijkstra, encontrando el camino más corto en un grafo con pesos. Representando las divisas como los nodos del grafo y las tasas de cambio como aristas con pesos. Especificamente para cada par de divisas $c_{i}$ y $c_{j}$, podemos crear una arista de $c_{i}$ a $c_{j}$ con un peso de $-log(r_{i},j)$, se hace uso del algoritmo negativo ya que la tasa de intercambio satisface la condición de $r_{i,j}*r_{j,i} < 1$\\\\ La idea es transformar las tasas de intercambio en retornos logarítmicos. Esta propiedad es de ayuda, ya que nos permite hacer uso de algoritmos para encontrar el camino más corto (Dijkstra) y así encontrar el camino con mejores ganancias. \\ Con los pesos de las aristas representados como logaritmos negativos convirtiendo el problema con pesos no negativos, de esta forma es posible hacer uso del algoritmo de Dijkstra, de otra forma se usaria el algoritmo de Bellman Ford para aristas negativas.\\\\ La complejidad es \textbf{O($|$E$|$+$|$V$|$log$|$V$|$)}, hay que señalar que a raíz de que hacemos uso de logaritmos, necesitamos tener cuidado con aristas que sean cercanas a cero.}

\subsection{Implementación}
\href{https://github.com/luisballado/ADA/tree/main/practice_code/tarea5/currency_trading}{ver código en github}\\

Ejecutar desde una terminal\\\\

El archivo data.txt contiene los datos de
\begin{itemize}
\item \textbf{monedas, tasas de cambio}
\item \textbf{moneda origen, moneda destino, tasa de cambio}
\item \textbf{moneda origen, moneda destino}
\end{itemize}

% Command-line "screenshot"
\begin{commandline}
\begin{verbatim}
  $ g++ -std=c++11 currency_trading.cpp -o currency_trading
  $ ./currency_trading < data.txt
  El intercambio de 0 a 3 es 0.4
\end{verbatim}
\end{commandline}

\newpage
\section{Referencias}
Rate of return - \url{https://en.wikipedia.org/wiki/Rate_of_return}\\\\
Returns and Log Returns - \url{https://gregorygundersen.com/blog/2022/02/06/log-returns}\\\\
The Breadth-first search algorithm - \url{https://wwww.khanacademy.org/computing/computer-science/algorithms/breadth-first-search/a/the-breadth-first-search-algorithm}\\\\
COMPSCI 311: Introduction to Algorithms - \\\url{https://people.cs.umass.edu/~marius/class/cs311-fa18/lec15-nup.pdf}\\\\
Arbitrage as a Shortest-Path Problem - \\\url{https://hackernoon.com/arbitrage-as-a-shortest-path-problem-u2l34ow}\\\\
Currency Arbitrage using Bellman Ford Algorithm - \\\url{https://anilpai.medium.com/currency-arbitrage-using-bellman-ford-algorithm-8938dcea56ea}\\\\
Temas de C++ - \\\url{https://www.fing.edu.uy/tecnoinf/mvd/cursos/eda/material/teo/EDA-teorico14.pdf}\\\\
Array de vectores en C++ - \url{https://www.geeksforgeeks.org/array-of-vectors-in-c-stl/}\\\\
Vectores C++ - \url{https://www.programiz.com/cpp-programming/vectors}\\\\
Implementacion de un grafo para programacion competitiva \\ \url{https://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/}

\end{document}

